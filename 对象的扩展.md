# ------------------------对象的扩展----------------------- #

<p id="tit"></p>
                       
## :mortar_board:目录 ##

:arrow_down:<a href="#a1">1.属性的简洁表示法</a>

:arrow_down:<a href="#a2">2.属性名表达式</a>


<p id="a1"></p>
       
### 	:bookmark:属性的简洁表示法 ###

:arrow_double_up:<a href ="#tit">返回目录</a>

ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。

```JavaScript
let age = 12;
let id = '2017110329';


let student = {
  'name' : 'lumnca',
  age,
  id
}

alert(student.name);    //lumnca
alert(student.id);      //2017110329
alert(student.age);     //12
```

上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。

```JavaScript
function studnts(name,id,age){
  return {name,id,age};
}

var s1 = studnts('lumnca','2017110329',19);
 
alert(s1.name);     //lumnca
alert(s1.id);       //2017110329
alert(s1.age);      //19
```

上面的函数返回的一个对象，对象里面的name,id,age就相当于属性值，参数值传入属性值。除了属性简写，方法也可以简写。

```JavaScript
let person = {
  say(text){
    alert(text);
  }
}

person.say("Hello!");
```

在ES5方法都是像这样写的：

```JavaScript
let person = {
    say : function(text){
      alert(text);
    }
}

person.say("Hello!");
```

可以看出使用属性的简洁表示法可以帮助我们简化许多工作。这种写法用于函数的返回值，将会非常方便。

```JavaScript
function getPoint() {
  const x = 1;
  const y = 10;
  return {x, y};
}

getPoint()
// {x:1, y:10}
```

CommonJS 模块输出一组变量，就非常合适使用简洁写法。

```JavaScript
let ms = {};

function getItem (key) {
  return key in ms ? ms[key] : null;
}

function setItem (key, value) {
  ms[key] = value;
}

function clear () {
  ms = {};
}

module.exports = { getItem, setItem, clear };
// 等同于
module.exports = {
  getItem: getItem,
  setItem: setItem,
  clear: clear
};
```

属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。

```JavaScript
const cart = {
  _wheels: 4,

  get wheels () {
    return this._wheels;
  },

  set wheels (value) {
    if (value < this._wheels) {
      throw new Error('数值太小了！');
    }
    this._wheels = value;
  }
}
```

注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。

```JavaScript
const obj = {
  class () {}
};

// 等同于

var obj = {
  'class': function() {}
};
```

上面代码中，class是字符串，所以不会因为它属于关键字，而导致语法解析报错。

如果某个方法的值是一个 Generator 函数，前面需要加上星号。

```JavaScript
const obj = {
  * m() {
    yield 'hello world';
  }
};
```

<p id="a2"></p>
       
### 	:bookmark:属性名表达式 ###

:arrow_double_up:<a href ="#tit">返回目录</a>

JavaScript 定义对象的属性，有两种方法。

```JavaScript
// 方法一
obj.foo = 123;

// 方法二
obj['foo'] = 123;
```

上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。

```JavaScript
let point = {
   x : 2,        //直接定义属性名
   'y' : 3,      //字符型定义
   ['r'] : 1,    //方括号事定义
}

alert(point.x+","+point.y);    //2,3
alert(point.r);                //1
```

表达式还可以用于定义方法名。

```JavaScript
let point = {
   x : 2,
   'y' : 3,
   ['r'] : 1,
   ['show'](){
      alert(this.x+","+this.y);
   }
}

point.show();
```

注意，属性名表达式与简洁表示法，不能同时使用，会报错。

```JavaScript
// 报错
const foo = 'bar';
const bar = 'abc';
const baz = { [foo] };

// 正确
const foo = 'bar';
const baz = { [foo]: 'abc'};
```

注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。

```JavaScript
const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};

myObject // Object {[object Object]: "valueB"}
```

上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。





















